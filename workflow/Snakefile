import logging
import glob
import math
import os
from snakemake.io import expand, glob_wildcards


LOGGER = logging.getLogger("snakemake.logging")

if not "REPROFLOW_BASEDIR" in dir():
    # NOTE when used from a module workflow.basedir (and main_snakefile) always point to most-outer wrapping layer, workflow.current_basedir (and snakefile) to the current module
    REPROFLOW_BASEDIR = workflow.current_basedir
    # print(REPROFLOW_BASEDIR)
LOGGER.info("REPROFLOW_BASEDIR = %s", REPROFLOW_BASEDIR)


configfile: "../config/config.yaml"

# if os.path.exists("config/config.yaml"):
#
#     configfile: "config/config.yaml"
#
# elif os.path.exists("config.yaml"):
#
#     configfile: "config.yaml"


include: "rules/process_fastq.smk"


if config["replicate"]["pair_type"] == "single":

    include: "rules/create_replicates_single.smk"

elif config["replicate"]["pair_type"] == "paired":

    include: "rules/create_replicates_paired.smk"


selected_tools = config["alignment"]["selected_tools"]

if "bwa2" in selected_tools:

    include: "rules/bwa2.smk"


if "bowtie2" in selected_tools:

    include: "rules/bowtie2.smk"


include: "rules/parser.smk"
include: "rules/comparer.smk"


SAMPLES = ["ERR009308"]
TOOLS = selected_tools
# print(SAMPLES, TOOLS)


############### HELPER FUNCTIONS #################
def _limit_number_of_replicates(info) -> int:
    number = min(
        config["replicate"]["replicate_number"],
        math.factorial(info) - 1,
    )
    return number


narr = _limit_number_of_replicates(config["replicate"]["record_len"]) + 1
# print(range(1,narr))


def gather_checkpoint_outputs_paired(wildcards):
    # print(
    #     "check_out_paired: ",
    #     checkpoints.create_replicates_paired.get(**wildcards).output[0],
    #     checkpoints.create_replicates_paired.get(**wildcards).output[1],
    # )
    return [
        checkpoints.create_replicates_paired.get(**wildcards).output[0],
        checkpoints.create_replicates_paired.get(**wildcards).output[1],
    ]


def gather_checkpoint_outputs_single(wildcards):
    # print(
    #     "check_out_single: ",
    #     checkpoints.create_replicates_single.get(**wildcards).output[0],
    # )
    return checkpoints.create_replicates_single.get(**wildcards).output[0]


# Define a function to return the appropriate list of input files based on the condition
ext = ".csv"
out_folder = config["assessment"]["comparer_out"]

def get_fastq():
    return (
        expand(
            config["replicate"]["output_folder"]
            + "{sample}_sh{n}_R1.fastq",
            sample=SAMPLES,
            n=range(1,narr)
        )
        + expand(
            config["replicate"]["output_folder"]
            + "{sample}_sh{n}_R2.fastq",
            sample=SAMPLES,
            n=range(1,narr)
        )
    )


def get_inputs():
    if config["replicate"]["pair_type"] == "single":
        return (

            # expand(
            #     out_folder
            #     + "{tool}/{sample}_sh{n}_{pair}"
            #     + ext,
            #     sample=SAMPLES,
            #     tool=TOOLS,
            #     n=range(1, narr),
            #     pair="S",
            # )
            # + expand(
            #     out_folder + "{tool}/{sample}_original_{pair}" + ext,
            #     sample=SAMPLES,
            #     tool=TOOLS,
            #     pair="S",
            # )
            expand(
                out_folder + "{tool}/{sample}_sh{n}-original_{pair}" + ext,
                sample=SAMPLES,
                tool=TOOLS,
                n=range(1, narr),
                pair="S",
            )

            + expand(
                config["replicate"]["output_folder"] + "{sample}_{pair}_info.csv",
                sample=SAMPLES,
                pair="S",
            )
        )

    else:
        return (
            # expand(
            #     out_folder
            #     + "{tool}/{sample}_sh{n}_{pair}"
            #     + ext,
            #     sample=SAMPLES,
            #     tool=TOOLS,
            #     n=range(1, narr),
            #     pair="R",
            # )
            # + expand(
            #     out_folder + "{tool}/{sample}_original_{pair}" + ext,
            #     sample=SAMPLES,
            #     tool=TOOLS,
            #     pair="R",
            # )
            expand(
                out_folder + "{tool}/{sample}_sh{n}-original_{pair}" + ext,
                sample=SAMPLES,
                tool=TOOLS,
                n=range(1, narr),
                pair="R",
            )
            + expand(
                config["replicate"]["output_folder"] + "{sample}_{pair}_info.csv",
                sample=SAMPLES,
                pair="R",
            )
        )


# print(get_inputs())
print(get_fastq())


# Use the function in the rule
rule all:
    input:
        get_inputs(),

        # get_fastq(),
        # config["assessment"]["comparer_out"] + "done.txt"
        # gather_checkpoint_outputs_paired
        #all_input


################################################################################
# ruleorder: generate_csv > create

# rule last:
#     input:
#         expand(config["assessment"]["comparer_out"] + "{tool}/{sample}_{type}-original_{pair}.csv",
#             tool=TOOLS, sample=SAMPLES, type=["sh1", "sh2", "sh3"], pair="R"),
#     output:
#         config["assessment"]["comparer_out"] + "done.txt"
#     run:
#         shell("touch {output}")
